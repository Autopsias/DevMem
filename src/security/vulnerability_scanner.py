from dataclasses import dataclass
from typing import Dict, List, Any, Optional
from datetime import datetime
import re
import hashlib
import json

@dataclass
class SecurityVulnerability:
    severity: str  # "critical", "high", "medium", "low"
    category: str  # "code", "configuration", "dependency"
    description: str
    file_path: Optional[str]
    line_number: Optional[int]
    recommendation: str
    timestamp: datetime

@dataclass
class ScanResult:
    vulnerabilities: List[SecurityVulnerability]
    scan_duration: float
    files_scanned: int
    rules_checked: int
    timestamp: datetime

class VulnerabilityScanner:
    def __init__(self):
        self.scan_history: List[ScanResult] = []
        self.vulnerability_rules = self._load_security_rules()
        
    def _load_security_rules(self) -> Dict[str, Any]:
        return {
            "code": {
                "patterns": {
                    "secrets_in_code": {
                        "severity": "critical",
                        "regex": r"(?i)(api[_-]key|secret|password|token)['\"]?\s*[:=]\s*['\"][^'\"]+['\"]",
                        "description": "Potential hardcoded secret found",
                        "recommendation": "Remove secrets from code and use environment variables"
                    },
                    "sql_injection": {
                        "severity": "critical",
                        "regex": r"f['\"]SELECT.*\{.*\}|f['\"]INSERT.*\{.*\}|f['\"]UPDATE.*\{.*\}",
                        "description": "Potential SQL injection vulnerability",
                        "recommendation": "Use parameterized queries instead of string formatting"
                    },
                    "command_injection": {
                        "severity": "critical",
                        "regex": r"os\.system\(|subprocess\.call\(|eval\(|exec\(",
                        "description": "Potential command injection vulnerability",
                        "recommendation": "Validate and sanitize all user input before execution"
                    }
                }
            },
            "configuration": {
                "required_settings": {
                    "tls_version": {
                        "min_version": "1.2",
                        "severity": "high",
                        "description": "TLS version below minimum required",
                        "recommendation": "Configure TLS 1.2 or higher"
                    },
                    "access_control": {
                        "required": True,
                        "severity": "high",
                        "description": "Missing access control configuration",
                        "recommendation": "Implement role-based access control"
                    }
                }
            },
            "dependencies": {
                "banned_packages": [
                    {
                        "name": "insecure-crypto",
                        "severity": "critical",
                        "description": "Package with known vulnerabilities",
                        "recommendation": "Remove or replace with secure alternative"
                    }
                ],
                "version_constraints": {
                    "requests": ">= 2.25.0",
                    "cryptography": ">= 3.4.0"
                }
            }
        }
        
    def scan_code_file(self, file_path: str, content: str) -> List[SecurityVulnerability]:
        vulnerabilities = []
        
        # Scan for code patterns
        for pattern_name, rule in self.vulnerability_rules["code"]["patterns"].items():
            for match in re.finditer(rule["regex"], content, re.MULTILINE):
                line_number = content[:match.start()].count("\n") + 1
                vulnerabilities.append(SecurityVulnerability(
                    severity=rule["severity"],
                    category="code",
                    description=rule["description"],
                    file_path=file_path,
                    line_number=line_number,
                    recommendation=rule["recommendation"],
                    timestamp=datetime.now()
                ))
                
        return vulnerabilities
        
    def scan_configuration(self, config: Dict[str, Any]) -> List[SecurityVulnerability]:
        vulnerabilities = []
        required = self.vulnerability_rules["configuration"]["required_settings"]
        
        # Check TLS version
        tls_version = config.get("security", {}).get("tls_version")
        if not tls_version or tls_version < required["tls_version"]["min_version"]:
            vulnerabilities.append(SecurityVulnerability(
                severity=required["tls_version"]["severity"],
                category="configuration",
                description=required["tls_version"]["description"],
                file_path=None,
                line_number=None,
                recommendation=required["tls_version"]["recommendation"],
                timestamp=datetime.now()
            ))
            
        # Check access control
        if not config.get("security", {}).get("access_control", {}).get("enabled"):
            vulnerabilities.append(SecurityVulnerability(
                severity=required["access_control"]["severity"],
                category="configuration",
                description=required["access_control"]["description"],
                file_path=None,
                line_number=None,
                recommendation=required["access_control"]["recommendation"],
                timestamp=datetime.now()
            ))
            
        return vulnerabilities
        
    def scan_dependencies(self, requirements: Dict[str, str]) -> List[SecurityVulnerability]:
        vulnerabilities = []
        rules = self.vulnerability_rules["dependencies"]
        
        # Check banned packages
        for package in rules["banned_packages"]:
            if package["name"] in requirements:
                vulnerabilities.append(SecurityVulnerability(
                    severity=package["severity"],
                    category="dependency",
                    description=f"Detected use of banned package: {package['name']}",
                    file_path="requirements.txt",
                    line_number=None,
                    recommendation=f"Remove {package['name']}: {package['recommendation']}",
                    timestamp=datetime.now()
                ))
                
        # Check version constraints
        for package, constraint in rules["version_constraints"].items():
            if package in requirements:
                installed_version = requirements[package]
                if not self._check_version_constraint(installed_version, constraint):
                    vulnerabilities.append(SecurityVulnerability(
                        severity="high",
                        category="dependency",
                        description=f"Package {package} version {installed_version} below minimum required {constraint}",
                        file_path="requirements.txt",
                        line_number=None,
                        recommendation=f"Upgrade {package} to version {constraint}",
                        timestamp=datetime.now()
                    ))
                    
        return vulnerabilities
        
    def _check_version_constraint(self, version: str, constraint: str) -> bool:
        # Simple version comparison - in real implementation use packaging.version
        constraint_op = constraint[:2]
        constraint_ver = constraint[2:].strip()
        
        if constraint_op == ">=":
            return version >= constraint_ver
        elif constraint_op == "<=":
            return version <= constraint_ver
        return version == constraint_ver
        
    def generate_security_report(self, scan_result: ScanResult) -> Dict[str, Any]:
        # Count vulnerabilities by severity
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }
        
        for vuln in scan_result.vulnerabilities:
            severity_counts[vuln.severity] += 1
            
        # Calculate risk score (0-100)
        weights = {"critical": 1.0, "high": 0.7, "medium": 0.4, "low": 0.1}
        max_score = sum(weights.values()) * 100
        current_score = sum(
            weights[sev] * count * 25 
            for sev, count in severity_counts.items()
        )
        risk_score = min(100, (current_score / max_score) * 100) if max_score > 0 else 0
        
        return {
            "summary": {
                "scan_timestamp": scan_result.timestamp.isoformat(),
                "duration_seconds": scan_result.scan_duration,
                "files_scanned": scan_result.files_scanned,
                "rules_checked": scan_result.rules_checked,
                "total_vulnerabilities": len(scan_result.vulnerabilities),
                "risk_score": risk_score
            },
            "vulnerability_counts": severity_counts,
            "findings": [
                {
                    "severity": v.severity,
                    "category": v.category,
                    "description": v.description,
                    "file_path": v.file_path,
                    "line_number": v.line_number,
                    "recommendation": v.recommendation
                }
                for v in scan_result.vulnerabilities
            ],
            "recommendations": {
                "critical": [
                    v.recommendation
                    for v in scan_result.vulnerabilities
                    if v.severity == "critical"
                ],
                "high": [
                    v.recommendation
                    for v in scan_result.vulnerabilities
                    if v.severity == "high"
                ]
            }
        }